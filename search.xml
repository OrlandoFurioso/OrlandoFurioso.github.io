<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux下的sockets学习</title>
    <url>/2025/02/27/Linux%E4%B8%8B%E7%9A%84sockets%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Socket基础概念"><a href="#Socket基础概念" class="headerlink" title="Socket基础概念"></a>Socket基础概念</h1><p>Socket，又称套接字，是Linux跨进程通信方式的一种。其既可以实现同一台主机内跨进程通信，也可以实现不同主机之间的跨进程通信。<strong>根据通信域的不同可以划分为两种：Unix domain socket和Internet domain socket</strong></p>
<p>网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“端口”可以唯一标识主机中的应用程(进程）。这样利用三元组（<strong>ip地址,协议, 端口</strong>）就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。<strong>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层</strong></p>
<p>在因特网通信过程中：应用程序要为因特网通信而创建一个套接字（socket）时，操作系统就返回一个<strong>小整数</strong>作为描述符（descriptor）来标识这个套接字。然后应用程序以该描述符作为传递参数，通过调用相应函数（如read、write、close等）来完成某种操作（如从套接字中读取或写入数据）。</p>
<span id="more"></span>

<h1 id="Socket操作API函数"><a href="#Socket操作API函数" class="headerlink" title="Socket操作API函数"></a>Socket操作API函数</h1><img data-src="/2025/02/27/Linux%E4%B8%8B%E7%9A%84sockets%E5%AD%A6%E4%B9%A0/%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%80%9A%E4%BF%A1%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B.png" class="">

<p>接下来站在整体层面上，对Socket函数进行介绍：</p>
<p><strong>getaddrinfo函数利用DNS进行域名和IP的转换操作</strong>，其输入为一个域名，输出为一系列潜在的匹配IP地址。</p>
<p><strong>socket函数创建一个文件描述符</strong>。用于在接下来的操作中指定连接。</p>
<p><strong>客户端的Connect函数是一个主动打开的函数</strong>，因为一个客户主机知道服务器的相关信息，并主动请求服务。实际上，connect函数接收一个文件描述符和一个IP地址作为输入，若成功执行，则创建一个连接。</p>
<p><strong>服务器端的bind, listen函数组合在一起</strong><br>bind函数接收一个文件描述符作为输入，告知内核将该文件描述符与给定的(ip, port)对联系起来。<br>成功执行完bind函数后，listen函数接收一个已经与一个(ip, port)对绑定起来的文件描述符作为输入，告知内核当前服务器端已经准备好接收客户端连接</p>
<p><strong>服务器端的accept函数是一个被动的函数</strong>，其等待与用户的连接。接收一个已经被listen函数激活的文件描述符作为输入，创建一个新的文件描述符，以用于和一台客户主机建立连接。</p>
<p>小结以下前面描述的关系：通过socket函数创建socketfd（socket文件描述符），调用socketfd依次执行bind, listen和accept函数。用于一台服务器服务多个用户，因此每当有客户和服务器建立连接时，accept函数将创建新的fd，用于特别地标识出服务器与该客户的连接。</p>
<p>当客户主机与服务器建立连接后，应用层协议开始接手工作，双方进行数据的传输。每一边都可以通过send（发送数据）, recv（接收数据）, close（关闭连接）函数进行所期望实现的操作。<br>send, recv函数接收文件描述符作为输入，向OS发送相应字节数的数据（由创建的缓存buffer进行限制）以进行传输或是向OS请求相应字节数的数据，工作机制与read&amp;write函数类似。</p>
<p>close函数接收一个特定的文件描述符作为输入，成功执行时，将告知内核中断当前连接。内核收到通知后，不会立即停止传输，而是会将当前缓存中的数据传输完成后，发送特殊的<code>EOF</code>信息，标志传输的结束。</p>
<h2 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h2><p>函数定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数:<br><strong>domain：指定发送通信的域</strong><br>可选参数：<br>AF_UNIX：本地主机通信，与IPC类似<br>AF_INET：Internet地址IPV4协议<br>AF_INET6：Internet地址IPV6协议</p>
<p><strong>type：指定socket类型</strong><br>可取值：<br>SOCK_STREAM(流套接字)，提供序列化的，可靠的，双向的，基于连接的数据流。<br>SOCK_DGRAM(数据报套接字)，支持无连接的，不可靠的，限定了最大长度的信息。<br>SOCK_RAW(原始套接字)，即提供了原始的网络协议访问权限</p>
<p><strong>protocol：指定该套接字描述符上的一个特殊的协议，如TCP，UDP等，一般设为0,会自动选择type的类型对应的协议</strong></p>
<p><strong>返回值：</strong><br>成功：返回创建的套接字描述符<br>失败：-1</p>
<p>补充：SOCK_STREAM(流套接字)应用TCP协议，提供顺序的，可靠的，基于字节流的双向链接<br>SOCK_DGRAM(数据报套接字)应用UDP协议，无链接，不可靠，不固定<br>SOCK_RAW(原始套接字)提供访问互联网协议和Internal Network Interfaces的权限，只有超级用户才可使用。</p>
<p><strong>实例如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> sockfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">  <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，我们往往将创建所得的套接字表述符存入对应的变量，并引入相关的异常处理机制。</p>
<h2 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h2><p>TCP客户端调用socket创建socket_fd后，再调用connect函数连接服务器。若此时客户端调用connect函数发送连接请求后，服务器端就会收到这个请求，并使得accept函数返回。accept函数返回的信道文件描述符即为对应到该客户的TCP连接。</p>
<p>通过这两个文件描述符（客户端connect的fd和服务器端accept返回的fd），即可实现客户端和服务器端的相互通信。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数:<br>sockfd: 客户端的socket()创建的描述字，用于唯一地标识一个socket。<br>addr: 要连接的服务器的socket地址信息，这里面包含有服务器的IP地址和端口等信息<br>addrlen: socket地址的长度</p>
<p><strong>在调用connect函数之前，还需要设置服务器的IP地址，端口信息到addr中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址清零,ipv4,把端口转换网络字节序,点十进制转发为32为整形ip地址</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(SERVER_PORT);</span><br><span class="line"><span class="built_in">inet_aton</span>(SERVER_IP,&amp;serv_addr.sin_addr);</span><br><span class="line"></span><br><span class="line">rv = <span class="built_in">connect</span>(sockfd,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="built_in">sizeof</span>(serv_addr));</span><br><span class="line"><span class="keyword">if</span>(rv &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Failed to connect server:%s\n&quot;</span>,SERVER_IP,SERVER_PORT,<span class="built_in">strerror</span>(errno));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Connecting to the server[%s:%d] successfully\n&quot;</span>,SERVER_IP,SERVER_PORT);</span><br></pre></td></tr></table></figure>

<h2 id="Bind函数"><a href="#Bind函数" class="headerlink" title="Bind函数"></a>Bind函数</h2><p>调用socket函数创建socket时，返回的socket描述字存在于协议族空间中，但是没有具体的地址，若希望赋值一个地址，则需要调用bind函数。通常服务器在启动时都会绑定一个约定俗成的地址（ip地址+端口号）用于提供服务，以便客户用其连接服务器。</p>
<p>而客户端不需要指定，由系统自动分配一个端口号和自身的IP地址结合即可。通常服务器端在listen函数之前会调用bind函数，而客户端就不会调用，而是由connect函数由系统随机生成一个。当然客户端也可以在调用connect函数之前bind一个地址和端口，这样就能使用特定的IP和端口来连服务器了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：<br>sockfd：即socket描述字，通过socket()函数创建的，唯一标识一个socket。bind()函数即是给这个描述字绑定一个名字。</p>
<p>addr：一个const struct sockaddr*指针，指向要绑定给sockfd的协议地址。地址结构根据地址创建socket时地址协议族的不同而不同。</p>
<p>addrlen：对应的是addr的长度。</p>
<p><strong>在调用bind()函数之前，还需要设置客户端的ip地址，端口信息到addr中</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清零地址,ipv4, 端口网络转换主机字节序,监听所以的ip转换为主机字节序</span></span><br><span class="line"></span><br><span class="line"># DEFINE SERVER_PORT <span class="number">50001</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line"> <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"> addr.sin_family = AF_INET;</span><br><span class="line"> addr.sin_addr.s_addr = INADDR_ANY;</span><br><span class="line"> addr.sin_port = <span class="built_in">htons</span>(SERVER_PORT); <span class="comment">//调用htons函数将端口由主机字节序转换为网络字节序</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// Add the exception handler.</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">bind</span>(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="built_in">sizeof</span>(addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">   <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">   <span class="built_in">close</span>(sockfd);</span><br><span class="line">   <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数<br>sockefd: socket()系统调用创建的要监听的socket描述字<br>backlog: 相应socket可以在内核里排队的最大连接个数</p>
<h2 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h2><p>TCP服务器端依次调用socket函数、bind函数、listen函数之后，就会监听指定的socket地址了。服务器之后就会调用accpet函数接受来自客户端的连接请求，这个函数默认是一个<strong>阻塞函数</strong>，这也意味着如果没有客户端连接服务器的话该程序将<strong>一直阻塞着不会返回</strong>，直到有一个客户端连过来为止。一旦客户端调用connect函数就会触发服务器的accept函数返回，这时整个TCP链接就建立好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数<br>sockfd: 服务器开始调用socket()函数生成的，称为监听socket描述字；<br>addr： 用于返回客户端的协议地址，这个地址里包含有客户端的IP和端口信息等；<br>addrlen: 返回客户端协议地址的长度</p>
<p><strong>以下是一段accept函数的示例代码：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//监听socket,等待客户端连接,创建一个新的fd,创建新的客户端地址和客户端地址长度</span></span><br><span class="line">client_fd = <span class="built_in">accept</span>(socket_fd,(<span class="keyword">struct</span> sockaddr*)&amp;cli_addr,&amp;cliaddr_len);</span><br><span class="line"><span class="keyword">if</span>(client_fd &lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;accept new socket failure :%s\n&quot;</span>,<span class="built_in">strerror</span>(errno));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将网络地址转换点十进制地址,把客户端地址的ipv4和客户端端口转发成点十进制</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;accept new client[%s:%d] wlth fd [%d]\n&quot;</span>,<span class="built_in">inet_ntoa</span>(cli_addr.sin_addr),<span class="built_in">ntohs</span>(cli_addr.sin_port),client_fd);</span><br></pre></td></tr></table></figure>

<p>accept函数的返回值是由内核自动生成的一个全新的描述字(fd)，代表与返回客户的TCP连接。若服务器希望发送数据给该客户端，则我们<strong>调用write()函数</strong>向该fd中写内容即可；而若客户端希望从该服务器读取数据，则<strong>调用read()函数</strong>从该fd中读取内容即可。</p>
<p>一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个新的socket描述字，当服务器完成了对某个客户的服务，就应当把该客户端相应的的socket描述字关闭。</p>
<h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><h3 id="htons-htonl函数"><a href="#htons-htonl函数" class="headerlink" title="htons&#x2F;htonl函数"></a>htons&#x2F;htonl函数</h3><p><strong>作用</strong>：将主机字节序（小端字节序）改写为网络字节序（大端字节序）</p>
<p><strong>htons: host network short（2字节&#x2F;16位），端口号为16位<br>htonl: host network long（4字节&#x2F;32位），IP地址32位</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"></span><br><span class="line">serv_addr.sin_port=<span class="built_in">htons</span>(LISTEN_PORT);</span><br><span class="line">serv_addr.sin_addr.s_addr=<span class="built_in">htonl</span>(INADDR_ANY);</span><br></pre></td></tr></table></figure>

<p>htons把端口号由<strong>主机字节序转换为网络字节序</strong><br>htonl把ip地址由<strong>主机字节序转换为网络字节序</strong></p>
<p>hostlong为主机字节顺序表达的32位数<br>hostshort位主机字节顺序表达的16位数。</p>
<p><strong>ntohs（16位），ntohl（32位）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>;</span><br></pre></td></tr></table></figure>

<p>ntohs将无符号转换短字符从网络字节顺序到主机字节顺序<br>ntohl将无符号转换整数从网络字节顺序到主机字节顺序<br>INADDR_ANY指定地址为0.0.0.0地址,表示监听所有的IP地址</p>
<p>netlong:一个以网络字节顺序表达的32位数<br>netshort:一个以网络字节顺序表达的16位数</p>
<img data-src="/2025/02/27/Linux%E4%B8%8B%E7%9A%84sockets%E5%AD%A6%E4%B9%A0/%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F.png" class="">
<p>一般来说，我们使用的主机字节序为小端字节序，网络字节序为大端字节序。我们常用的IP地址和端口直接写成二进制就是主机字节序，调换位置后变为网络字节序。</p>
<h3 id="inet-aton和inet-ntoa函数"><a href="#inet-aton和inet-ntoa函数" class="headerlink" title="inet_aton和inet_ntoa函数"></a>inet_aton和inet_ntoa函数</h3><p><strong>作用：inet_aton函数将点十进制字符串转换成网络地址，inet_ntoa函数将网络地址转换成点十进制字符串格式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *string, <span class="keyword">struct</span> in_addr *addr)</span></span>;</span><br><span class="line"><span class="comment">//将字符串表示的网络地址转换为该地址数值的整数表示，返回的数字总是按照网络字节顺序的</span></span><br></pre></td></tr></table></figure>

<p>参数描述：<br>输入参数string包含ASCII表示的IP地址。<br>输出参数addr是将要用新的IP地址更新的结构。</p>
<p>返回值：<br>如果这个函数成功，函数的返回值非零。如果输入地址不正确则会返回零。<br>使用这个函数并没有错误码存放在errno中，所以他的值会被忽略</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span></span><br><span class="line"><span class="function"><span class="comment">//将网络传输的二进制数值转化为成点分十进制的ip地址</span></span></span><br></pre></td></tr></table></figure>

<p>返回指向点分十进制字符串的指针。该函数将一个网络字节顺序的IP地址转换为它所对应的点分十进制串。<br>注意：对inet_aton的调用传递的是指向结构的指针，而对inet_ntoa的调用传递的是结构本身。</p>
<h3 id="inet-pton-inet-ntop函数"><a href="#inet-pton-inet-ntop函数" class="headerlink" title="inet_pton&#x2F;inet_ntop函数"></a>inet_pton&#x2F;inet_ntop函数</h3><p><strong>inet_pton:</strong><br>IP地址转换函数,支持IPv4&#x2F;IPv6，可以在将IP地址从“点分十进制”转换成网络字节顺序表示Internet地址。<br><strong>inet_ntop:</strong><br>IP地址转换函数,支持IPv4&#x2F;IPv6，可以在将网络字节顺序表示的Internet地址转换成为“点分十进制”</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">nt <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"> <span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;172.20.223.151&quot;</span>, &amp;servaddr.sin_addr);</span><br></pre></td></tr></table></figure>

<p>参数：<br>af:可以是AF_INET（对应的是ipv4）或AF_INET6(ipv6)，如果以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.<br>src:是一个指向点分十进制串的指针，<br>dst:是一个指向转换后的网络字节序的二进制值的指针。</p>
<p>返回值：<br>若成功则为1，若输入不是有效的表达式则为0，若出错则为-1，并将errno置为EAFNOSUPPORT.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src,<span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"> <span class="built_in">inet_ntop</span>(AF_INET, &amp;servaddr.sin_addr, IPdotdec, <span class="number">16</span>);</span><br></pre></td></tr></table></figure>

<p>参数：<br>af:可以是AF_INET（对应的是ipv4）或AF_INET6(ipv6)，如果,以不被支持的地址族作为family参数，这两个函数都返回一个错误，并将errno置为EAFNOSUPPORT.<br>src:是一个指向点分十进制串的指针，<br>dst:参数不可以是一个空指针。调用者必须为目标存储单元分配内存并指定其大小，调用成功时，这个指针就是该函数的返回值。<br>size:是所指向缓存区dst的大小，避免溢出，如果缓存区太小无法存储地址的值，则返回一个空指针，并将errno置为ENOSPC</p>
<h3 id="read-write函数"><a href="#read-write函数" class="headerlink" title="read&#x2F;write函数"></a>read&#x2F;write函数</h3><p><strong>作用：read函数从fd中读取内容，write函数向fd中写内容</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd , <span class="type">void</span> *buf,<span class="type">size_t</span> nbytes)</span></span></span><br></pre></td></tr></table></figure>

<p>参数：<br>sockfd：与远程通信连接的套接字描述符<br>buf：接收数据的缓冲区地址<br>len：缓冲区长度</p>
<p>read函数负责从fd中读取内容。当读成功时read返回实际所读的字节数；如果返回的值是0表示已经读到文件的结束了，如果是网络socket fd也就意味着TCP 链接断开了；小于0表示出现了错误并设置错误标志到errno全局变量中，如果错误为EINTR说明读是由中断引起的，如果ECONNREST表示网络连接出了问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbyte)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数：<br>int fildes : 写入文件的文件描述符<br>const void *buf: 写入数据在内存空间存储的地址<br>size_t nbyte : 期待写入数据的最大字节数</p>
<p>write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节 数。失败时返回-1，并设置errno变量。在网络程序中，当我们向套接字文件描述符写时有俩种可能。write的返回值大于0，表示写了部分或者全部的数据。返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p>
<p><strong>网络I&#x2F;O函数还包括以下这些</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr,<span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags，<span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span>*addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="close-shutdown函数"><a href="#close-shutdown函数" class="headerlink" title="close&#x2F;shutdown函数"></a>close&#x2F;shutdown函数</h3><p>在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用close函数来关闭一样。close一个TCP socket的缺省行为时把该socket标记为以关闭，然后立即返回到调用进程</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> how)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数<br>fd:要关闭的文件<br>how:值为 SHUT_RD 则该套接字不可再读入数据了<br>SHUT_WR 则该套接字不可再发送数据了<br>SHUT_RDWR 则该套接字既不可以读，也不可以写数据了</p>
<h3 id="send-recv函数"><a href="#send-recv函数" class="headerlink" title="send&#x2F;recv函数"></a>send&#x2F;recv函数</h3><p>send函数将待发送数据复制入缓存中，交给协议进行发送；recv函数将数据从缓存中取出，进行接收。</p>
<p><strong>send函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">send</span> <span class="params">(SOCKET s, <span class="type">const</span> <span class="type">char</span> FAR *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不论是客户还是服务器应用程序都用send函数来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答。</p>
<p>该函数的第一个参数指定发送端套接字描述符；</p>
<p>第二个参数指明一个存放应用程序要发送数据的缓冲区；</p>
<p>第三个参数指明实际要发送的数据的字节数；</p>
<p>第四个参数一般置0。</p>
<p><strong>当调用send函数时</strong>，send先比较待发送数据的长度len和套接字s的发送缓冲的长度， 如果len大于s的发送缓冲区的长度，该函数返回SOCKET_ERROR；如果len小于或者等于s的发送缓冲区的长度，那么send先检查协议是否正在发送s的发送缓冲中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送s的发送缓冲中的数据或者s的发送缓冲中没有数据，那么send就比较s的发送缓冲区的剩余空间和len</p>
<p>若len大于剩余空间大小，则send一直等待协议将s的发送缓冲中的数据发送完。若len小于剩余空间大小，则send仅仅将buf中的数据复制到剩余空间中。<strong>注意并不是send把s的发送缓冲中的数据传到连接的另一端的，而是协议传的，send仅仅是把buf中的数据copy到s的发送缓冲区的剩余空间里</strong></p>
<p>如果send函数copy数据成功，就返回实际copy的字节数，如果send在copy数据时出现错误，那么send就返回SOCKET_ERROR；如果send在等待协议传送数据时网络断开的话，那么send函数也返回SOCKET_ERROR。</p>
<p>send函数把buf中的数据成功copy到缓冲的剩余空间里后就返回了，但是这些数据不会被马上传输到连接的另一端。</p>
<p><strong>recv函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">recv</span> <span class="params">(SOCKET s, <span class="type">char</span> FAR *buf, <span class="type">int</span> len, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>不论是客户还是服务器应用程序都用recv函数从TCP连接的另一端接收数据。该函数的第一个参数指定接收端套接字描述符；</p>
<p>第二个参数指明一个缓冲区，该缓冲区用来存放recv函数接收到的数据；</p>
<p>第三个参数指明buf的长度；</p>
<p>第四个参数一般置0。</p>
<p><strong>当调用recv函数时</strong>，recv先等待s的发送缓冲中的数据被协议传送完毕，如果协议在传送s的发送缓冲中的数据时出现网络错误，那么recv函数返回SOCKET_ERROR，如果s的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv先检查套接字s的接收缓冲区，如果s接收缓冲区中没有数据或者协议正在接收数据，那么recv就一直等待，直到协议把数据接收完毕。</p>
<p>当协议把数据接收完毕，recv函数就会把接收缓存中的数据copy到buf中。<strong>注意协议接收到的数据可能大于buf的长度，所以在这种情况下要调用几次recv函数才能把s的接收缓冲中的数据copy完。recv函数仅仅是copy数据，真正的接收数据是协议来完成的</strong></p>
<p>recv函数返回其实际copy的字节数。如果recv在copy时出错，那么它返回SOCKET_ERROR；如果recv函数在等待协议接收数据时网络中断了，则返回0。</p>
<h3 id="fopen-fclose函数"><a href="#fopen-fclose函数" class="headerlink" title="fopen&#x2F;fclose函数"></a>fopen&#x2F;fclose函数</h3><p><strong>fopen函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name, <span class="type">const</span> <span class="type">char</span> *mode_of_operation)</span></span>;</span><br></pre></td></tr></table></figure>

<p>接受两个参数，文件名称和对文件执行的操作模式。</p>
<p>文件操作模式包括：r（只读）, w（文件存在时覆盖其内容，不存在时创建对应文件），a（只在尾部插入）, r+（读写），rb（只读，二进制文件）</p>
<p><strong>实例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> FILE *demo;</span><br><span class="line"></span><br><span class="line"> demo = <span class="built_in">fopen</span>(<span class="string">&quot;demo_file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line"> <span class="built_in">fprintf</span>(demo, <span class="string">&quot;%s %s %s&quot;</span>, <span class="string">&quot;Welcome&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;myhome&quot;</span>);</span><br><span class="line"> <span class="built_in">fclose</span>(demo);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fwrite-fread函数"><a href="#fwrite-fread函数" class="headerlink" title="fwrite&#x2F;fread函数"></a>fwrite&#x2F;fread函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> nmemb, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到这个函数的<strong>参数</strong>有四个：</p>
<p>第一个ptr是要写入的数据的<strong>头指针</strong>，无符号类型；</p>
<p>第二个参数size是<strong>大小</strong>，表示每个写入元素的大小，单位是字节；</p>
<p>第三个参数nmemb是<strong>个数</strong>，以上一个参数为单位的个数；</p>
<p>第四个参数stream就是<strong>文件指针</strong>，表示往哪里写。</p>
<p>至于返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。</p>
]]></content>
      <categories>
        <category>网络编程实践</category>
      </categories>
      <tags>
        <tag>network_programming</tag>
      </tags>
  </entry>
  <entry>
    <title>Prompt engineering入门学习</title>
    <url>/2025/08/06/Prompt-engineering%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Prompt engineering(提示工程)，是调整优化提示词(prompt)，以引导大模型生成预期的回答的一项技术。对于同样的大模型，可以通过利用prompt engineering清晰地描述问题，明确解决问题的步骤，规范回答格式的方式，提高回答的质量。场景不同，分析的问题不同，使用的prompt engineering策略也不尽相同。以下是常见的优化提示词的思路，可供参考</p>
<h1 id="1-给出清晰的指令"><a href="#1-给出清晰的指令" class="headerlink" title="1.给出清晰的指令"></a>1.给出清晰的指令</h1><h2 id="1-1-询问过程中应当包含问题细节，以获取相关度更高的答案"><a href="#1-1-询问过程中应当包含问题细节，以获取相关度更高的答案" class="headerlink" title="1.1 询问过程中应当包含问题细节，以获取相关度更高的答案"></a>1.1 询问过程中应当包含问题细节，以获取相关度更高的答案</h2><p>若提示词表达不够清楚，则模型会尝试基于已有信息推测用户意图，这可能造成理解上的偏差：</p>
<p>以下提供几组Prompt对照，以说明给出清晰的指令的重要性：</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>Worse</th>
<th>Better</th>
</tr>
</thead>
<tbody><tr>
<td>谁是美国总统</td>
<td>2024年的美国总统是谁，总统多久选举一次？</td>
</tr>
<tr>
<td>提供一段计算斐波那契数列的代码</td>
<td>编写一个基于C++的函数以高效计算斐波那契数列，并提供必要的注释以说明每一部分代码做了什么，为何这样做</td>
</tr>
<tr>
<td>总结会议记录</td>
<td>用一段文字总结会议记录。随后，用Markdown的形式列出会议中的每一个说话者和他们对应的观点。最后，列出每个说话者提出的下一步计划</td>
</tr>
</tbody></table>
<h2 id="1-2-让模型代入相应的角色"><a href="#1-2-让模型代入相应的角色" class="headerlink" title="1.2 让模型代入相应的角色"></a>1.2 让模型代入相应的角色</h2><p>通过为模型预设对应的角色，能够引导模型深入思考相关领域的知识，从而生成更加符合预期的结果：</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System:</span><br><span class="line">假设你是一名作家，你的写作风格幽默风趣。在写作时，你为我创作的每一段内容中需要至少包含一个笑话或者有趣的点。</span><br><span class="line"></span><br><span class="line">User:</span><br><span class="line">我的大学英语老师Jenny，在我上课时提供了很多帮助，热心地回答了我的疑惑。在我创作毕业论文时，帮助我润色了其中的内容，并修复了语法上的许多错误。在我申请斯坦福大学的研究生时，她为我写了相应的推荐信，帮助我获得了面试的机会。请为我写一封对Jenny老师的感谢信。</span><br></pre></td></tr></table></figure>

<p>(注：系统消息(system message)是用于设定模型的行为、角色和响应方式的消息。它通常在对话开始时就被设定，并在整个对话过程中保持一致，帮助模型明确其角色和工作目标。而用户消息(user message)是用户向模型输入的请求或指令，模型将根据这个消息生成相应的回复。用户消息通常包括明确的任务要求、问题或对话内容。)</p>
<h2 id="1-3-使用分隔符增强文本可读性"><a href="#1-3-使用分隔符增强文本可读性" class="headerlink" title="1.3 使用分隔符增强文本可读性"></a>1.3 使用分隔符增强文本可读性</h2><p>常用的分隔符（包括三引号<code>&quot;&quot;&quot;</code>, XML标签等），都可以帮助划分需要区别对待的文本部分，帮助大模型快速识别重要信息。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用俳句概括以下内容：</span><br><span class="line">&quot;&quot;&quot;插入文字&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你将会收到两篇关于相同话题的文章（用XML标签进行了分割）。首先，你需要概括每篇文章的论点，随后，你需要判断这两篇文章中哪一篇的论点更好，并说明原因。</span><br><span class="line">&lt;article&gt; 插入第一篇文章 &lt;/article&gt;</span><br><span class="line">&lt;article&gt; 插入第二篇文章 &lt;/article&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你将会收到一篇论文的摘要和这篇论文暂定的标题。论文的标题应当在让读者对论文讨论的话题有着明确认识的基础上，做到引人注意。假设当前暂定的标题不符合这一预期，提供5个替代的标题供我参考。</span><br><span class="line"></span><br><span class="line">Abstract: 在此插入摘要</span><br><span class="line">Title: 在此插入标题</span><br></pre></td></tr></table></figure>

<p>对于简单的，容易理解的任务，使用分隔符不会显著提升生成结果的质量。但是在复杂的情景中，使用分隔符能够极大地。</p>
<h2 id="1-4-分解复杂的任务，提供可行的解决步骤"><a href="#1-4-分解复杂的任务，提供可行的解决步骤" class="headerlink" title="1.4 分解复杂的任务，提供可行的解决步骤"></a>1.4 分解复杂的任务，提供可行的解决步骤</h2><p>复杂的任务往往可以被分解为一系列基本的步骤。通过引导模型一步步地执行这些步骤，可以提高最终生成结果的质量。</p>
<p>示例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System：</span><br><span class="line">请你遵照用户指示，一步步操作，根据用户输入完成操作：</span><br><span class="line"></span><br><span class="line">步骤1: 用户将提供用三括号分割后的文本。在一个句子内概括文本中的内容，句子的前缀为：&quot;总结：&quot;</span><br><span class="line"></span><br><span class="line">步骤2: 将步骤1中的总结翻译为西班牙语，翻译后的结果前面应当加上前缀：&quot;翻译为：&quot;</span><br></pre></td></tr></table></figure>

<h2 id="1-5-提供具体的参考实例"><a href="#1-5-提供具体的参考实例" class="headerlink" title="1.5 提供具体的参考实例"></a>1.5 提供具体的参考实例</h2><p>对于某些难以用语言直接加以描述的情景，可以通过提供示例，帮助大模型快速理解问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">仿照前文风格进行写作:</span><br><span class="line"></span><br><span class="line">我通过以下句式阐述耐心的概念：</span><br><span class="line">&quot;&quot;&quot;The river that carves the deepest valley flows from a modest spring; the grandest symphony originates from a single note; the most intricate tapestry begins with a solitary thread.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">请你仿照我提供的句式，用英语对海洋(ocean)的概念进行描述</span><br></pre></td></tr></table></figure>

<h2 id="1-6-限定回答的长度"><a href="#1-6-限定回答的长度" class="headerlink" title="1.6 限定回答的长度"></a>1.6 限定回答的长度</h2><p>可以对模型的回答长度进行一些限制。可以限制的部分包括：句子数，段落数，要点个数等。需要特别说明的是，通常难以让大模型使用限定个数的词进行回答。在限定回答长度时，可以指示大模型使用特定数量的段落或特定次数的要点来尝试回答问题，这样效果比较好。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用50个词左右概括以下文本</span><br><span class="line">&quot;&quot;&quot;text&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在两个自然段内完成以下内容的概括</span><br><span class="line">&quot;&quot;&quot;text&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将以下内容概括为三个要点</span><br><span class="line">&quot;&quot;&quot;text&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h1 id="2-提供参考文本"><a href="#2-提供参考文本" class="headerlink" title="2.提供参考文本"></a>2.提供参考文本</h1><h2 id="2-1-指示大模型使用参考文本回答问题"><a href="#2-1-指示大模型使用参考文本回答问题" class="headerlink" title="2.1 指示大模型使用参考文本回答问题"></a>2.1 指示大模型使用参考文本回答问题</h2><p>大模型的训练是一个耗时耗力的过程，其知识更新的速度往往不及真实的环境中信息更新的速度快。如果用户能够向大模型提供与问题相关的，可信的信息，模型将可以调用这些新的外部信息组织答案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用以下提供的两篇文章来回答以下两个问题。假设从文章中不能找到相应答案，则回答&quot;我不能从文中找到答案&quot;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;文章1&quot;&quot;&quot;</span><br><span class="line">&quot;&quot;&quot;文章2&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">问题：</span><br><span class="line">&lt;question1&gt;问题1&lt;/question1&gt;</span><br><span class="line">&lt;question2&gt;问题2&lt;/question2&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这样做的问题在于，所有的模型的上下文窗口都是有限的，若需要补充的外部知识很多，则无能为力。此时检索增强生成(Retrieve-augmented generation,RAG)应运而生，可以解决此类问题。其思想是，将外部知识来源(如文本文件等)中的内容进行切片，存入向量数据库中。当构造好相应的prompt传递给大模型时，将自动从关系数据库中寻找出与相关问题语义关联性最高的知识一并传递给大模型，从而增强大模型回答的相关性。此处已经脱离了prompt engineering的范畴，只做简要说明。</p>
<h2 id="2-2-要求模型从提供的参考文本中选取相应参考段落回答问题"><a href="#2-2-要求模型从提供的参考文本中选取相应参考段落回答问题" class="headerlink" title="2.2 要求模型从提供的参考文本中选取相应参考段落回答问题"></a>2.2 要求模型从提供的参考文本中选取相应参考段落回答问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System：</span><br><span class="line">你将会依照以下文档回答相应问题。</span><br><span class="line">你的任务是：仅使用提供的参考文档回答问题，并在回答问题时附上相应的参考段落。假设文档中的内容不足以回答问题，则直接回答&quot;当前提供的信息不足以回答问题&quot;</span><br><span class="line">注意：当你回答一个问题时，必须附上对应的关于参考文献的引用部分。在引用文献时，使用(&#123;&quot;citation&quot;:...&#125;)的格式输出</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;参考文档&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">问题：</span><br></pre></td></tr></table></figure>

<h1 id="3-将复杂的任务拆分成更简单的子任务"><a href="#3-将复杂的任务拆分成更简单的子任务" class="headerlink" title="3.将复杂的任务拆分成更简单的子任务"></a>3.将复杂的任务拆分成更简单的子任务</h1><h2 id="3-1-使用意图分类来确定与用户查询相关程度最高的指令"><a href="#3-1-使用意图分类来确定与用户查询相关程度最高的指令" class="headerlink" title="3.1 使用意图分类来确定与用户查询相关程度最高的指令"></a>3.1 使用意图分类来确定与用户查询相关程度最高的指令</h2><p>对于需要大量独立指令集来处理不同情况的任务。一个比较好的做法是：首先先分析用户意图，尝试对用户可能的查询类型进行分类，然后针对每个分类完善相应的处理指令。</p>
<p>在具体的实践中，首先会确定一系列固定的分类，随后，将针对不同分类下不同情况设置相应的处理指令。以上过程可以递归进行，以将一个复杂的任务分解为一个由不同状态组成的序列。</p>
<p>这种方式类似状态转换图，接受到特定的输入后即跳转到特定的状态，做出特定的回答。其相较于传统分析的优势在于，每次查询仅包含执行任务下一阶段所需的指令。与使用单个查询执行整个任务相比，错误率更低，成本也更低。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你是一名产品客服，你的工作任务是耐心倾听并回答客人的问题。为了完成任务，你需要将客人的问题进行分类，分类为一级类别和二级类别。最终以JSON格式提供输出结果</span><br><span class="line"></span><br><span class="line">一级类别中包含这些大类：付款，技术支持，账户管理，通用问题</span><br><span class="line"></span><br><span class="line">进一步进行细分，付款大类中包含以下二级类别：</span><br><span class="line"></span><br><span class="line">- 订阅以及取消订阅</span><br><span class="line">- 添加支付方式</span><br><span class="line">- 收款说明</span><br><span class="line">- 对收款提出异议</span><br><span class="line"></span><br><span class="line">技术支持中包含以下二级类别：</span><br><span class="line"></span><br><span class="line">- 问题定位</span><br><span class="line">- 设备适用性</span><br><span class="line">- 软件更新</span><br><span class="line"></span><br><span class="line">帐号管理中包含以下二级类别：</span><br><span class="line"></span><br><span class="line">- 密码重置</span><br><span class="line">- 更新个人信息</span><br><span class="line">- 注销帐号</span><br><span class="line">- 帐号安全</span><br><span class="line"></span><br><span class="line">通用问题中包含以下二级类别：</span><br><span class="line"></span><br><span class="line">- 产品信息</span><br><span class="line">- 价格</span><br><span class="line">- 用户反馈</span><br><span class="line">- 呼叫人工服务</span><br></pre></td></tr></table></figure>

<p>基于上述分类，我们可以定义出一系列更加具体的处理方式并提供给模型。譬如，此时判断用户需要<code>问题定位</code>相关的帮助。进一步细化处理方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你将收到在`技术支持`一级类别下关于问题定位的客户服务咨询。你将通过以下方式帮助用户：</span><br><span class="line"></span><br><span class="line">- 首先，你将引导用户检查连接路由器的网线是否松动。需要注意的是，随着时间推移，网线松动属于正常现象。</span><br><span class="line">- 假设所有的网线连接正常且问题继续发生，询问用户使用的路由器版本</span><br><span class="line">- 此时你将建议用户重启路由器，并观察效果，不同的路由器重启方式不一致。</span><br><span class="line">- 假设用户路由器版本为MTD-327J，建议他们按住红色按钮5秒以上以进行重启，并在下次测试连接前等待5分钟</span><br><span class="line">- 假设用户路由器版本为MTD-327S，建议他们重新插拔连接路由器的网线，并在下次测试连接前等待5分钟</span><br><span class="line">- 假设用户在重启路由器并等待5分钟后问题依然持续，通过回复&#123;&quot;IT support requested&quot;&#125;的方式，将当前会话转接到IT支持处。</span><br><span class="line">- 假设用户开始询问与当前话题不相关的问题，则可以确定他们希望终结当前关于问题定位的相关会话。随后，你需要将用户的请求按照以下分类标准进行重新分类。</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;分类标准&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>通过上述的示例分析，我们发现，我们可以通过让模型执行相应指令，来改变当前对话的状态。这允许我们将我们的系统转变为状态机。通过跟踪状态，处理对应状态的指令，以及可能转换到当前状态的状态，我们能够实现精确地跟踪用户需求。<br>以上概念有些类似于Agent智能体，可以根据需要，为大模型”定制”一套其可以调用的函数接口，并引导大模型在适当的时候对其进行调用，从而完成特定情景下的任务</p>
<h2 id="3-2-在长对话情景中，总结或过滤之前的对话"><a href="#3-2-在长对话情景中，总结或过滤之前的对话" class="headerlink" title="3.2 在长对话情景中，总结或过滤之前的对话"></a>3.2 在长对话情景中，总结或过滤之前的对话</h2><p>由于模型接收文本长度的限制，用户与大模型的对话（整个对话都包含在上下文窗口中）不可能无限期地进行下去。</p>
<p>(译者注：模型在生成回复时，会将<strong>当前用户输入以及之前的对话内容</strong>（系统消息、用户输入和模型回复）一并作为上下文输入，形成一个连续的对话历史。这意味着只要上下文窗口内仍有空间，模型可以“记住”前文的内容并据此生成与当前对话相关的回复。但如果对话过长，超过上下文窗口限制，最早的内容会被截断，模型将不再能访问这些信息。)</p>
<p>为了解决长对话的问题，有以下的方案：<br><strong>一是总结先前的对话</strong>。当先前的对话长度超过了预先设定的长度阈值，这将触发一次对先前对话的总结，并生成关于先前对话中的摘要。在实际情况下，先前的对话将在整个会话中异步地在后台进行总结。</p>
<p><strong>二是动态选取先前对话中与当前话题相关的部分</strong>。详情参见RAG</p>
<h2 id="3-3-对长文档进行分段摘要，并递归地构造完整摘要"><a href="#3-3-对长文档进行分段摘要，并递归地构造完整摘要" class="headerlink" title="3.3 对长文档进行分段摘要，并递归地构造完整摘要"></a>3.3 对长文档进行分段摘要，并递归地构造完整摘要</h2><p>由于大模型的上下文长度窗口是固定的，因此，<strong>大模型无法对长度长于(上下文长度窗口-生成摘要长度)的文本生成摘要</strong></p>
<p>因此，为了总结一段非常长的文本，如一整本书。我们可以先对文本进行预处理，分为不同的小节，并引导大模型对每个小节进行概括。随后，每个小节的总结可以拼接起来，传递给大模型，以进一步进行概括，生成关于全文的总结。这一过程可以递归地进行，直到对整个文档完成总结。</p>
<p>假设为了概括后续部分的内容，需要用到前面的信息。此时还有一个技巧，就是在总结文本中某一部分内容的同时，对该部分先前的内容做一个流水帐式的总结。这对于模型深入理解前后部分之间的关联有着很大的帮助。</p>
<h1 id="4-给予模型思考的时间"><a href="#4-给予模型思考的时间" class="headerlink" title="4.给予模型思考的时间"></a>4.给予模型思考的时间</h1><h2 id="4-1-指示模型在思考出实际的解决方案之前不要匆匆给出结论"><a href="#4-1-指示模型在思考出实际的解决方案之前不要匆匆给出结论" class="headerlink" title="4.1 指示模型在思考出实际的解决方案之前不要匆匆给出结论"></a>4.1 指示模型在思考出实际的解决方案之前不要匆匆给出结论</h2><p>模型有时会受到外部提问者提问方式的诱导，从而得出具有某种倾向性的结果。此时，为了得到更加准确的结果，我们需要指示模型从问题本身入手，在得出结论前先进行思考，不要急忙下定论。</p>
<p>反面示例:直接要求大模型给出答案，可能出现问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于以下数学问题，判断以下学生给出的解决方案是否正确:</span><br><span class="line"></span><br><span class="line">问题描述：</span><br><span class="line">我正准备计算建设太阳能电站的开销，请根据以下信息分析：</span><br><span class="line">土地开销为每平方米土地100$</span><br><span class="line">太阳板开销为每平方米250$</span><br><span class="line">维护费用为：在100k$的初始费用的基础上，加收10$每平方米的额外费用</span><br><span class="line">按照平方米计算，运行该电站第一年的总成本是多少？</span><br><span class="line"></span><br><span class="line">学生的答案：</span><br><span class="line">假设该电站占地面积为x平方米</span><br><span class="line">1.土地开销：100x</span><br><span class="line">2.太阳能板开销：250x</span><br><span class="line">3.维护费用：100,000+100x</span><br><span class="line">因此总开销为：100x+250x+100,000+100x=450x+100,000</span><br></pre></td></tr></table></figure>

<p>此时模型可能给出错误的答案。因为先入为主的观念可能会让模型顺着错误的思路思考。</p>
<p>正面示例:引导大模型理解整个问题后再作答</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">首先，先就以下问题思考出你自己的解决方案。随后，将你自行思考得出的解决方案与以下提供的解决方案进行对比。评估以下解决方案是否正确。不要在你独立思考出以下问题的解决方案前就判断提供的解决方案是否正确</span><br><span class="line"></span><br><span class="line">问题描述：</span><br><span class="line">我正准备计算建设太阳能电站的开销，请根据以下信息分析：</span><br><span class="line">土地开销为每平方米土地100$</span><br><span class="line">太阳板开销为每平方米250$</span><br><span class="line">维护费用为：在100k$的初始费用的基础上，加收10$每平方米的额外费用</span><br><span class="line">按照平方米计算，运行该电站第一年的总成本是多少？</span><br><span class="line"></span><br><span class="line">提供的解决方案：</span><br><span class="line">假设该电站占地面积为x平方米</span><br><span class="line">1.土地开销：100x</span><br><span class="line">2.太阳能板开销：250x</span><br><span class="line">3.维护费用：100,000+100x</span><br><span class="line">因此总开销为：100x+250x+100,000+100x=450x+100,000</span><br></pre></td></tr></table></figure>

<h2 id="4-2-使用内心独白或是一个查询序列来隐藏模型的思考过程"><a href="#4-2-使用内心独白或是一个查询序列来隐藏模型的思考过程" class="headerlink" title="4.2 使用内心独白或是一个查询序列来隐藏模型的思考过程"></a>4.2 使用内心独白或是一个查询序列来隐藏模型的思考过程</h2><p>先前的策略强调，模型在回答特定问题之前，需要对问题进行详细推理。但是在特定的应用场合下，模型推出最终答案的推理过程不适合展示给用户。譬如在线教育场景中，直接显示推理过程相当于把答案告诉学生。</p>
<p><strong>内心独白是一种解决以上问题的策略</strong>。其思想为：指示模型将应当对用户隐藏的部分输出转化为结构化格式，以便应用端进行解析。随后，应用端在对用户展示输出结果之前，先对输出结果进行解析，只让部分结果可见。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遵照以下步骤回应用户查询：</span><br><span class="line"></span><br><span class="line">步骤1: 首先自行得出问题的答案。不要依赖任何学生提供的解答进行作答。将你在该步骤中得出的所有结果用三引号(&quot;&quot;&quot;)进行标注</span><br><span class="line"></span><br><span class="line">步骤2: 将你的解答过程与学生的解答过程进行比较，随后评估学生的解答过程是否正确。将你在该步骤中得出的所有结果用三引号(&quot;&quot;&quot;)进行标注。</span><br><span class="line"></span><br><span class="line">步骤3: 假设学生的解答中存在错误，在不直接提供答案给学生的前提下，判断你应该提供给学生何种提示。将你在该步骤中得出的所有结果用三引号(&quot;&quot;&quot;)进行标注。</span><br><span class="line"></span><br><span class="line">步骤4: 假设学生的解答中存在错误，将步骤3中生成的提示提供给学生，(输出时结果不要放在三引号&quot;&quot;&quot;中)，在生成提示的前面加上&quot;提示如下：&quot;的前缀</span><br><span class="line"></span><br><span class="line">问题描述：&lt;插入问题描述&gt;</span><br><span class="line"></span><br><span class="line">学生提供的解答过程:&lt;插入学生提供的解题方法&gt;</span><br></pre></td></tr></table></figure>

<p>除了内心独白，<strong>我们还可以通过一个查询序列实现向用户隐藏关键信息</strong>。此时仅向用户展示最后一个序列输出的结果。</p>
<p>回到上面的为学生评卷的情景中。首先，我们先要求模型自己解决问题。这样做的好处是，模型的解法不会因为参考了学生的解法而被带偏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">问题描述：&lt;插入问题描述&gt;</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以指示模型判断学生解法的正确性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将你前面对于该问题的解法与以下提供的学生的解法进行对比，并评估学生的做法是否正确：</span><br><span class="line"></span><br><span class="line">问题描述：&quot;&quot;&quot;&lt;插入问题描述&gt;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">你的解决方法：&quot;&quot;&quot;&lt;插入前文中生成的解决方法&gt;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">学生的解决方法：&quot;&quot;&quot;&lt;插入学生的解决方法&gt;&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>最终，我们可以指示模型通过自己的分析，以一个乐于助人的辅导员的角色来构建一个回复。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你是一名数学辅导员。如果学生出错了，以不透露答案的方式向学生提供提示。如果学生没有出错，只需给他们一个鼓励性的评论。</span><br><span class="line"></span><br><span class="line">问题陈述： &quot;&quot;&quot;&lt;插入问题陈述&gt;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">你的解决方案: &quot;&quot;&quot;&lt;插入模型生成的解决方案&gt;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">学生的解决方案： &quot;&quot;&quot;&lt;插入学生的解决方案&gt;&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">分析： &quot;&quot;&quot;&lt;插入上一步生成的模型分析&gt;&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-询问模型之前是否遗漏了任何内容"><a href="#4-3-询问模型之前是否遗漏了任何内容" class="headerlink" title="4.3 询问模型之前是否遗漏了任何内容"></a>4.3 询问模型之前是否遗漏了任何内容</h2><p>假设这样的情景：我们正在使用一个模型来列出与特定问题相关的信息源片段。在列出每个片段后，模型需要确定是否应该开始编写另一个片段，还是应该停止编写。如果源文件很大，模型很容易过早停止工作，无法列出所有相关片段。在这种情况下，通常可以提示模型在后续查询中搜索之前遗漏的片段，从而提高输出的质量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你将会接收一个用三引号(&quot;&quot;&quot;)分割的文档。你的任务是：选择与以下问题相关的片段：“人工智能历史上发生了哪些重大的范式转变。</span><br><span class="line"></span><br><span class="line">确保片段内容包含解释这些内容所需的所有相关上下文。换句话说，就是不要摘录缺少重要上下文的小片段。请你将结果按照JSON格式，参照以下的方式输出：</span><br><span class="line"></span><br><span class="line">[&#123;&quot;片段1&quot;:&quot;...&#125;,</span><br><span class="line">...</span><br><span class="line">&#123;&quot;片段n&quot;:&quot;...&quot;&#125;]</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;&lt;在此处插入文档&gt;&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>随后，在必要的时候提示模型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">还有更多相关片段吗？注意不要提供重复片段。还要确保片段内容包含解读相关内容所需的所有相关上下文，换句话说，不要提供缺少重要上下文的小片段。</span><br></pre></td></tr></table></figure>

<h1 id="5-使用外部工具辅助判断"><a href="#5-使用外部工具辅助判断" class="headerlink" title="5.使用外部工具辅助判断"></a>5.使用外部工具辅助判断</h1><h2 id="5-1-使用嵌入式搜索实现高效知识检索-RAG"><a href="#5-1-使用嵌入式搜索实现高效知识检索-RAG" class="headerlink" title="5.1 使用嵌入式搜索实现高效知识检索(RAG)"></a>5.1 使用嵌入式搜索实现高效知识检索(RAG)</h2><p>模型可以利用作为输入的一部分所提供的外部信息源，以生成相关性更强且更新的回应。例如，如果用户询问有关特定电影的问题，则将有关电影的高质量信息（例如演员、导演等）添加到模型的输入中可能会很有用。嵌入可用于实现高效的知识检索，从而可以在运行时动态地将相关信息添加到模型输入中。</p>
<p>RAG通过计算文本的向量相似度，从而评估向量数据库中文本的语义相关性，进而决定取出哪些文本。需要注意的是，RAG是一种较为取巧的方式，向量相似度高的两组文本未必在语义上一定相关。因此在实践中，RAG会取出前k个最相关的结果(topK)，这样无疑会影响效率</p>
<h2 id="5-2-通过执行代码或是调用外部程序接口完成精确运算"><a href="#5-2-通过执行代码或是调用外部程序接口完成精确运算" class="headerlink" title="5.2 通过执行代码或是调用外部程序接口完成精确运算"></a>5.2 通过执行代码或是调用外部程序接口完成精确运算</h2><p>大语言模型在执行算术或者长计算时是不可靠的。在需要的情况下，可以指示模型编写和运行代码，而不是自行进行计算。实践中，可以指示模型将要运行的代码以指定的格式输出，例如三重反引号(```)。产生输出后，可以提取并运行代码。最后，如有必要，可以将代码执行引擎（即 Python 解释器）的输出作为下一个查询的模型的输入。</p>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你可以编写并运行一段Python代码以解答以下数学问题，python代码应当用三重反括号(如```代码如下```)进行分隔。</span><br><span class="line"></span><br><span class="line">计算以下多项式的所有实根：3*x**5 - 5*x**4 - 3*x**3 - 7*x - 10.</span><br></pre></td></tr></table></figure>

<p>代码执行的另一个很好的用例是调用外部 API。通过指导模型正确调用 API，大模型将编写调用外部API的代码。还可以通过向模型提供 API 相关的文档或代码示例，指导模型更好地理解 API的使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你可以编写并运行一段Python代码以解答以下数学问题。同时在必要时，你可以访问通信模块并调用相应通信函数，该通信模块的主要功能是帮助用户发送信息给朋友。</span><br><span class="line"></span><br><span class="line">示例如下：</span><br><span class="line">```python</span><br><span class="line">import message</span><br><span class="line">message.write(to=&quot;John&quot;, message=&quot;Hey, want to meetup after work?&quot;) ```</span><br></pre></td></tr></table></figure>

<p><strong>值得注意的是，执行大模型提供的代码会存在安全问题，尤其是在调用外部API时。为了减小可能的损失，最好在沙盒环境内执行大模型生成的代码</strong></p>
]]></content>
      <categories>
        <category>大模型应用</category>
      </categories>
      <tags>
        <tag>大模型应用</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络课程笔记(一)</title>
    <url>/2025/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E5%85%B6%E4%B8%80/</url>
    <content><![CDATA[<h1 id="第一章：引入"><a href="#第一章：引入" class="headerlink" title="第一章：引入"></a>第一章：引入</h1><h2 id="Internet的组成"><a href="#Internet的组成" class="headerlink" title="Internet的组成"></a>Internet的组成</h2><p><strong>节点</strong></p>
<ul>
<li>主机及其上运行的应用程序</li>
<li>路由器，交换机等网络交换设备<br><strong>边：通信链路</strong></li>
<li>接入网链路：主机连结到互联网的链路</li>
<li>主干链路：路由器之间的链路</li>
</ul>
<h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><strong>网络边缘</strong></p>
<ul>
<li>主机</li>
<li>应用程序</li>
</ul>
<p>其中通信包含两种模式，C&#x2F;S模式和P2P模式<br>C&#x2F;S客户端向服务器请求，接收服务，如web端浏览器&#x2F;服务器<br>P2P模式很少或没有专门的服务器</p>
<p>TCP（传输控制协议）：Internet上面向连接的服务</p>
<ul>
<li>可靠地按照顺序地传送数据（确认和重传）</li>
<li>流量控制（发送方不会淹没接收方）</li>
<li>拥塞控制（网络拥塞时发送方降低发送速率）<br>使用TCP的应用包括HTTP，FTP，Telnet，SMTP</li>
</ul>
<p>UDP（用户数据包协议）：无连接服务</p>
<ul>
<li>无连接，不可靠数据传输，无流量控制，无拥塞控制<br>使用UDP的应用包括：流媒体，视频电话等</li>
</ul>
<span id="more"></span>

<p><strong>网络核心</strong></p>
<ul>
<li>互联的路由器</li>
<li>网络的网络</li>
</ul>
<h3 id="数据交换方式（重要）"><a href="#数据交换方式（重要）" class="headerlink" title="数据交换方式（重要）"></a>数据交换方式（重要）</h3><p>数据如何通过网络进行传输？<br><strong>电路交换</strong><br>每个呼叫一旦建立起来就独享资源，不共享以保障性能。通常被传统电话网络使用。<br>电路交换需要预先建立连接，交换过程分为三个阶段：建立连接，通信，释放连接。</p>
<p><strong>考虑延时时，需要考虑连接建立用时和数据传输用时</strong></p>
<p><strong>分组交换</strong><br>特点：</p>
<ol>
<li>将要传送的数据分为一个个单位，分组</li>
<li>将分组从一个路由器传递到相邻路由器，一段段最终从源端到目标端</li>
<li>每段采用链路的最大传输能力（带宽）<br><strong>考虑延时时，需要考虑中间存储转发的次数，和数据传输用时。还需要注意的是，进行分组时往往需要添加首部，需要考虑新的文件长度。</strong></li>
</ol>
<p><strong>报文交换</strong><br>特点：<br>等所有数据到达中间节点后再将数据传输到下一个节点，同样不需要建立一条专有线路。<br><strong>效率低下，需要等所有数据全部到达以后再进行下一次转发，同样需要考虑中间存储转发的次数。</strong><br>![[net1.png]]</p>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>支撑互联网工作的标准。 协议定义了在两个或多个通信实体之间交换的报文格式和次序，以及在报文传输或接收等事件方面采取的行动。</p>
<p>其组成要素包括：<br>语法：数据与控制信息的结构或格式<br>语义：需要发出何种控制信息，完成何种动作以及做出何种响应<br>同步：事件实现顺序的详细说明</p>
<table>
<thead>
<tr>
<th>网络应用（HTTP）</th>
<th>应用层</th>
</tr>
</thead>
<tbody><tr>
<td>可靠交付（TCP)</td>
<td>传输层</td>
</tr>
<tr>
<td>源-目的地发送（IP）</td>
<td>网络层</td>
</tr>
<tr>
<td>网络硬件（主机，路由器，电缆）</td>
<td>物理层</td>
</tr>
</tbody></table>
<p>实体表示任何可发送或接收信息的硬件或软件进程。协议是两个对等实体间进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层提供的服务。</p>
<h1 id="第二章：应用层协议"><a href="#第二章：应用层协议" class="headerlink" title="第二章：应用层协议"></a>第二章：应用层协议</h1><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p>应用层没有特定的协议，很多应用有自己的协议。</p>
<p>不同主机间通过sockets进行通信（套接字）<br>应用进程间使用sockets发送&#x2F;接收信息<br>应用编程接口（API）位于应用层和传输层之间，帮助应用访问系统内核（TCP&#x2F;IP协议软件）</p>
<p>IP地址本身不能唯一的标识进程，除非加上端口号。常用的端口号包括：</p>
<ul>
<li>HTTP server: 80</li>
<li>HTTPS: 443</li>
<li>SMTP mail server: 25</li>
<li>DNS server: 53</li>
<li>POP3: 110</li>
<li>IMAP: 143</li>
</ul>
<p>一对进程之间要通信，至少需要四个标识：![[net2.png]]</p>
<p>网络应用对传输服务的要求：<br>可靠性：数据丢失率（能否容忍差错）<br>实时性：端到端的时延<br>吞吐量：端到端的带宽<br>安全性：是否加密，是否验证用户身份，能否保证数据一致性。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>域名到32位IP地址之间的转换通过DNS进行，IP地址用于传输IP包，由主机和路由器识别。IP地址到48位MAC地址之间的转换由ARP进行。MAC地址用于在<strong>局域网中识别主机&#x2F;路由器</strong></p>
<p>DNS为采用分层结构的分布式数据库，提供主机名和IP地址映射的服务。<br>事实上，DNS有两重含义，也指允许主机查询分布式DNS数据库的应用层协议。</p>
<h3 id="DNS协议要点"><a href="#DNS协议要点" class="headerlink" title="DNS协议要点"></a>DNS协议要点</h3><ul>
<li>采用C&#x2F;S模型，client请求，server响应</li>
<li>客户端程序为resolver（解析器）</li>
<li>传输层采用UDP</li>
<li>DNS服务器默认访问端口号为53</li>
<li>DNS是其他应用层协议的支撑协议。<br>![[net3.png]]</li>
</ul>
<h3 id="主机域名的构成"><a href="#主机域名的构成" class="headerlink" title="主机域名的构成"></a>主机域名的构成</h3><p>![[net4.png]]</p>
<p>主机名由一系列由<code>.</code>分开的标签组成</p>
<ul>
<li>标签由字母和数字组成</li>
<li>每个标签不能超过63个字符</li>
<li>全部标签不能超过255个字符</li>
<li>书写顺序从主机开始，直到域名树的根为止，如：cs.bupt.edu.cn</li>
</ul>
<p>域名是一个组织在域名空间中的名字，如北邮：bupt.edu.cn，更多以组织形式进行划分</p>
<p>区是域名空间中的一部分，从域名管理的角度上划分，一个DNS服务器的管辖范围为一个区。每个区设置<strong>响应的权威服务器</strong>，用于管理该区中所有主机的域名到IP地址的映射。<br>![[net5.png]]</p>
<p>如上图中princeton大学本身作为一个域，下辖三个区，分别由三台权威服务器进行管理</p>
<h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><p>根据作用分为四类：</p>
<ul>
<li><p>根域名服务器</p>
</li>
<li><p>顶级域名服务器<br>负责管理该顶级域名注册的所有二级域名（如.edu, .cn等）</p>
</li>
<li><p>权威域名服务器<br>每台Internet的主机都应该在所在域的域名服务器注册，提供注册的域名服务器即为该主机的权威域名服务器。通常主机所在单位的DNS服务器就是权威域名服务器。</p>
</li>
<li><p>本地域名服务器<br>每个组织&#x2F;企业下属的DNS服务器。</p>
</li>
</ul>
<h3 id="DNS解析方式（迭代解析，递归解析）"><a href="#DNS解析方式（迭代解析，递归解析）" class="headerlink" title="DNS解析方式（迭代解析，递归解析）"></a>DNS解析方式（迭代解析，递归解析）</h3><p>![[net11.png]]</p>
<p>![[net12.png]]</p>
<h2 id="WWW应用与HTTP"><a href="#WWW应用与HTTP" class="headerlink" title="WWW应用与HTTP"></a>WWW应用与HTTP</h2><h3 id="WWW的体系结构"><a href="#WWW的体系结构" class="headerlink" title="WWW的体系结构"></a>WWW的体系结构</h3><p>万维网不是一个网络，而是基于因特网的信息服务系统。以C&#x2F;S模式工作。</p>
<p>HTTP协议实现通过WWW上的各种链接获取信息。</p>
<p>通过HTML(Hyper-text markup language)使得不同风格的页面在不同主机上显示，并表示超链接。</p>
<h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>其功能为向Web服务器发送请求信息，并接收Web服务器的响应信息。解释网页文档的源代码，并将网页呈现给用户。</p>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>统一资源定位符，唯一标识一个资源，对资源进行定位和访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www.abc.com:8080/example/example.html</span><br></pre></td></tr></table></figure>

<p>协议名：&#x2F;&#x2F;主机：端口号（若未指定则默认为80或443）&#x2F;文件路径及文件名</p>
<h3 id="网页（静态，动态，活跃）"><a href="#网页（静态，动态，活跃）" class="headerlink" title="网页（静态，动态，活跃）"></a>网页（静态，动态，活跃）</h3><p>静态网页：以文件形式保存，任何时候访问都返回相同的结果。<br>动态网页：收到浏览器请求后，服务器端动态生成网页。<br>活跃网页：收到服务器响应后，客户端依照服务器返回的代码，动态生成网页。</p>
<h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><p>HTTP为WWW的应用层协议</p>
<ul>
<li>采用C&#x2F;S模型</li>
<li>浏览器发送HTTP请求，接收HTTP响应，向用户呈现网页。</li>
<li>服务器接收HTTP请求，返回HTTP响应。</li>
<li>传输层采用TCP</li>
<li>为无状态协议，即服务器端不保存以前的访问记录，对于每个请求都是单独处理。</li>
</ul>
<p><strong>HTTP的操作过程</strong></p>
<ol>
<li>分析超链接</li>
<li>通过DNS获得服务器IP地址</li>
<li>建立到服务器的TCP链接</li>
<li>浏览器发送HTTP请求：GET &#x2F;example.html HTTP&#x2F;1.1</li>
<li>服务器发送HTTP响应</li>
<li>释放TCP链接</li>
<li>浏览器显示网页example.html</li>
</ol>
<h3 id="HTTP1-0（非持久连接），RTT"><a href="#HTTP1-0（非持久连接），RTT" class="headerlink" title="HTTP1.0（非持久连接），RTT"></a>HTTP1.0（非持久连接），RTT</h3><p>![[net6.png]]<br>一次连接只传输一个文件，若有多个文件需要传输，则需要建立多次连接。<br><strong>计算时间时，对于每个进行传输的文件，都需要考虑两个RTT的传输时间</strong></p>
<p><strong>RTT：Round Trip Time</strong><br>往返时间（两个方向的传播时延之和，与发送时延无关）<br>![[net7.png]]<br>HTTP1.0实现简单，但是缺点是每个对象都会有2*RTT的传播时延开销，且建立TCP连接有OS开销。用户需要建立多个TCP连接。</p>
<h3 id="HTTP1-1（持久连接）"><a href="#HTTP1-1（持久连接）" class="headerlink" title="HTTP1.1（持久连接）"></a>HTTP1.1（持久连接）</h3><p>![[net8.png]]</p>
<p>此时一个TCP连接可以传输多个对象，发送完响应后，Server不关闭连接，在一个TCP连接上可以传输多个对象。若采用非流水线机制的持久HTTP，则每个文件的传输时延为<strong>一个RTT</strong></p>
<p>同时，持久连接还可以采用流水线传输机制，此时总的传输时延为<strong>一个RTT</strong>。</p>
<p>流水线机制：Client可以连续发出多个请求，而不必等待前一个请求完成。<br>![[net9.png]]</p>
<h3 id="HTTP消息"><a href="#HTTP消息" class="headerlink" title="HTTP消息"></a>HTTP消息</h3><p>HTTP有两类消息：请求（request）和响应（response）<br>消息格式为ASCII文本。</p>
<p>以下为一个典型的HTTP请求消息：<br>GET &#x2F;somedir&#x2F;file HTTP&#x2F;1.1（请求行）<br>Host：<a href="http://www.abc.edu.cn/">www.abc.edu.cn</a><br>User-agent：Mozilla&#x2F;4.0<br>Accept-language：zh-cn<br>Connection：Keep-alive<br>（空行）<br>Body（请求体）</p>
<p>后四行为消息头（可选），一个空行表示消息头结束</p>
<table>
<thead>
<tr>
<th>HTTP方法</th>
<th>功能</th>
<th>支持的版本号</th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>从服务器下载URL到对应网页</td>
<td>HTTP1.0</td>
</tr>
<tr>
<td>PUT</td>
<td>将网页上传到URL指定的位置</td>
<td>HTTP1.1</td>
</tr>
<tr>
<td>POST</td>
<td>对URL指定的资源进行操作，如提交表格，在数据库中追加信息等</td>
<td>HTTP1.0</td>
</tr>
<tr>
<td>HEAD</td>
<td>向服务器请求URL对应的网页的消息头，不返回网页内容</td>
<td>HTTP1.0</td>
</tr>
<tr>
<td>DELETE</td>
<td>请求服务器删除URL对应的网页</td>
<td>HTTP1.1</td>
</tr>
<tr>
<td>TRACE</td>
<td>要求服务器返回请求消息，用于错误诊断</td>
<td>HTTP1.1</td>
</tr>
</tbody></table>
<p>HTTP响应信息：<br>HTTP&#x2F;1.1 200 OK（状态行）<br>以下五行均为可选消息头<br>Date：<br>Server：<br>Content-Length：<br>Content-Type：<br>Connection：<br>（空行）<br>data（网络数据）</p>
<h3 id="HTTP-Cookie"><a href="#HTTP-Cookie" class="headerlink" title="HTTP Cookie"></a>HTTP Cookie</h3><p>由于HTTP无状态性带来了限制，因此引入cookie保持访问状态</p>
<p>Cookie中包含以下内容：</p>
<ol>
<li>HTTP响应中包含一行set-cookie头信息</li>
<li>在HTTP请求中包含一行cookie头信息</li>
<li>Client主机中保存一个cookie文件，由浏览器管理</li>
<li>Server端的后台数据库</li>
</ol>
<p>以下为cookie请求及响应过程：<br>![[net10.png]]</p>
<h3 id="代理服务器与web缓存"><a href="#代理服务器与web缓存" class="headerlink" title="代理服务器与web缓存"></a>代理服务器与web缓存</h3><p>若设置通过代理进行访问。如果在代理中找到请求的对象，则由代理返回响应。否则代理将请求转发给要访问的web server，由该server响应。代理中缓存来自web server的网页对象。</p>
<p>同时浏览器缓存访问过的网页，进一步减少网络负载。</p>
<h2 id="Email应用"><a href="#Email应用" class="headerlink" title="Email应用"></a>Email应用</h2><p>特点：异步应用（收件人不需在线），提供一对多通信。</p>
<p>邮件消息格式包括IMF（仅支持ASCII文本邮件）和MIME（支持传输更多的数据类型）</p>
<h3 id="Email的通信协议"><a href="#Email的通信协议" class="headerlink" title="Email的通信协议"></a>Email的通信协议</h3><p>SMTP：发送&#x2F;转发邮件-&gt;PUSH服务<br>POP3或IMAP：从邮箱收邮件到本地计算机-&gt;PULL服务</p>
<p><strong>SMTP</strong><br>Simple Mail Transfer Protocol，采用C&#x2F;S模式，传输层协议使用TCP，端口号为25。采用直接传输，即邮件直接从发信人的服务器传输到收信人的服务器，而不从中间服务器转发。只支持ASCII文本文件。</p>
<p><strong>POP3</strong><br>Post Office Protocol，服务器端口号为110。作用为对用户进行身份认证，下载邮件到用户计算机。下载后从服务器删除，或在服务器上保留副本，会话状态信息不保留。服务器开销小。</p>
<p><strong>IMAP</strong><br>Internet Mail Access Protocol，服务器端口号为143，比POP功能强，更加复杂，可以在邮件服务器上处理邮件。邮件一直保留在服务器，服务器开销较大。</p>
<p>SMTP和POP3安全性不足，未强制要求对发信人身份进行认证，且发信人用户名和密码未进行加密（仅用64编码）邮件明文传输。因此采用SSL协议，对邮件进行加密后传输。</p>
<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>作用：将二进制代码映射至文本</p>
<p>先找到字符对应的ASCII码，将其写作对应的十进制数，再转化为对应的8位二进制数。随后，将二进制位每6个一组，重新转化为十进制数，找到该十进制数在Base64编码表中对应的字符，并转化为相应字符。</p>
<p>经过base64编码的字符串长度变为原来的8&#x2F;6倍（不考虑回车和换行符）</p>
<h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>文件传输协议，常用于将文件从服务器传输到客户端上。</p>
<p>FTP中包含了两个TCP连接，控制连接和数据连接</p>
<p>控制连接<br>FTP client首先与FTP server建立控制连接，该连接进行身份验证，传输命令和响应。该连接为持久连接，访问期间，控制连接一直存在。</p>
<p>数据连接<br>当需要传输数据时，由server或client建立数据连接，数据传输完连接即关闭。该连接为临时连接，若要传输下一个连接，则需要重新建立数据连接。</p>
<h2 id="Telnet与远程登录"><a href="#Telnet与远程登录" class="headerlink" title="Telnet与远程登录"></a>Telnet与远程登录</h2><p>TELNET是终端仿真协议，事实上是终端与计算机之间的通信协议。</p>
<p>Telnet采用C&#x2F;S模型，基于TCP实现。默认端口为23，支持双向通信。其安全性较差，故只用于受信任的网络中。</p>
<p>SSL位于应用协议与TCP&#x2F;IP之间，为了基于TCP的应用提供安全的传输通道。</p>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Kali Linux下安装Nvidia驱动的最佳实践</title>
    <url>/2025/08/06/Kali-Linux%E4%B8%8B%E5%AE%89%E8%A3%85Nvidia%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h2 id="一，禁用Nouveau开源驱动"><a href="#一，禁用Nouveau开源驱动" class="headerlink" title="一，禁用Nouveau开源驱动"></a>一，禁用Nouveau开源驱动</h2><p>Nouveau是Kali linux自带的一款开源驱动。若先前未禁用Nouveau，则首先需要禁用开源驱动Nouveau，因为其与nvidia显卡相性很差，可能导致kali系统不稳定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/modprobe.d/nouveau-blacklist.conf</span><br></pre></td></tr></table></figure>

<p>在文件中写入以下内容以禁用Nouveau：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="二，选择合适的驱动安装方式"><a href="#二，选择合适的驱动安装方式" class="headerlink" title="二，选择合适的驱动安装方式"></a>二，选择合适的驱动安装方式</h2><p>有两种驱动安装方式:</p>
<ol>
<li>通过 <code>apt</code> 包管理器管理驱动</li>
<li>在英伟达官网上下载对应的驱动文件(后缀为<code>.run</code>)，手动安装相应驱动。</li>
</ol>
<p>通过 <code>apt</code> 包管理攻击管理驱动方便后续更新维护；若手动下载安装驱动，则后续更新内核后，需要手动更新相应驱动文件。</p>
<span id="more"></span>

<hr>
<h2 id="三，通过官方驱动文件安装驱动"><a href="#三，通过官方驱动文件安装驱动" class="headerlink" title="三，通过官方驱动文件安装驱动"></a>三，通过官方驱动文件安装驱动</h2><p>首先简单说明如何通过后者，即从官网下载驱动文件安装驱动。<a href="https://www.nvidia.cn/drivers/lookup/">英伟达驱动下载地址</a></p>
<p>假设已经下载好了对应的驱动文件：</p>
<ol>
<li>若先前通过 <code>apt</code> 安装过nvidia驱动，则首先需要移除已有的全部驱动文件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt autoremove --purge <span class="string">&#x27;*nvidia*&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> apt autoremove --purge <span class="string">&#x27;libnvidia*&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装相应依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install build-essential linux-headers-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更新 initramfs (内核初始 RAM 盘) 并重启</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> update-initramfs -u</span><br><span class="line"><span class="built_in">sudo</span> reboot</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>进入文本交互模式并安装驱动<br>重启后，进入一个没有图形界面的TTY运行安装程序(ctrl + Alt + F1-F7切换TTY)<br>根据当前使用的桌面环境，停止当前的显示管理器服务：</li>
</ol>
<ul>
<li>GDM (GNOME): <code>sudo systemctl stop gdm</code></li>
<li>LightDM (XFCE, MATE): <code>sudo systemctl stop lightdm</code></li>
<li>SDDM (KDE): <code>sudo systemctl stop sddm</code></li>
</ul>
<ol start="5">
<li>进入保存<code>.run</code>文件的目录，安装驱动程序</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x NVIDIA-Linux-x86_64-*.run</span><br><span class="line"><span class="built_in">sudo</span> ./NVIDIA-Linux-x86_64-*.run</span><br></pre></td></tr></table></figure>

<ul>
<li>当被问及 “Would you like to register the kernel module sources with DKMS?” 时，强烈建议选择 “Yes”。这会让安装程序尝试使用 DKMS，以便在未来内核更新时自动重新编译模块，结合了手动安装和 DKMS 的优点。</li>
<li>当被问及是否安装 32 位兼容库时，通常选择 “Yes”。</li>
<li>让安装程序自动更新您的 X.org 配置文件。</li>
</ul>
<ol start="6">
<li>重启，并查看驱动信息</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>

<p>若顺利安装，则应当打印出相应显卡信息</p>
<hr>
<h2 id="四，通过apt动态安装管理驱动"><a href="#四，通过apt动态安装管理驱动" class="headerlink" title="四，通过apt动态安装管理驱动"></a>四，通过<code>apt</code>动态安装管理驱动</h2><p>有时侯，你使用的内核是Kali自行编译的，可以通过执行 <code>uname -r</code> 指令查看当前内核版本:</p>
<p>假设结果为官方发布的标准内核，则我们仅需要通过 <code>apt</code> 安装预编译驱动模块，即可以完成驱动的安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6.12.25-amd64</span><br></pre></td></tr></table></figure>

<p>若结果中出现 <code>kali</code> 字样，则说明当前内核由kali自行定制，此时我们需要通过动态编译 <code>dkms</code>， 使得驱动能够在自定义的内核下正常工作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6.12.33+kali-amd64</span><br></pre></td></tr></table></figure>

<p>若为前者，仅需要通过 <code>apt</code> 安装 <code>nvidia-driver</code> 即可，<code>apt</code> 会自行处理驱动与内核之间的依赖关系。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install nvidia-driver</span><br></pre></td></tr></table></figure>

<p>若为后者，则情况复杂一些，我们需要通过动态编译安装相应驱动</p>
<ol>
<li>安装好对应版本的内核头文件，动态编译工具等必要依赖</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install linux-headers-$(<span class="built_in">uname</span> -r) build-essential dkms</span><br></pre></td></tr></table></figure>

<p>安装完成后，可以通过以下指令，检查相应内核头文件是否被正确安装:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /lib/modules/$(<span class="built_in">uname</span> -r)/build</span><br></pre></td></tr></table></figure>

<p>若输出相应文件信息，则说明内核头文件被正确配置了</p>
<ol start="2">
<li>若先前安装过nvidia驱动，则首先需要将已有的nvidia驱动文件全部删除</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt autoremove --purge <span class="string">&#x27;*nvidia*&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> apt autoremove --purge <span class="string">&#x27;libnvidia*&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>通过 <code>apt</code> 安装驱动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install nvidia-driver nvidia-kernel-dkms</span><br></pre></td></tr></table></figure>

<p>完成安装后，检查DKMS状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dkms status</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重启并检验驱动完成安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>

<p>若打印显卡相关信息，则说明驱动安装完成</p>
<h2 id="补充-修复更新内核时，驱动动态编译失败的情况"><a href="#补充-修复更新内核时，驱动动态编译失败的情况" class="headerlink" title="补充: 修复更新内核时，驱动动态编译失败的情况"></a>补充: 修复更新内核时，驱动动态编译失败的情况</h2><p>有时完成内核更新后，DKMS自动编译会失败。这通常和新内核的头文件缺失有关，为此，安装最新版的内核头文件即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install linux-headers-$(<span class="built_in">uname</span> -r)</span><br></pre></td></tr></table></figure>

<p>手动触发编译:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dkms autoinstall</span><br></pre></td></tr></table></figure>

<p>重启并检验驱动完成安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> reboot</span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Kali Linux</category>
      </categories>
      <tags>
        <tag>Kali Linux</tag>
      </tags>
  </entry>
</search>
